{zone-template-instance:ZFDEV:Zend Proposal Zone Template}

{zone-data:component-name}
Zend_View Enhanced
{zone-data}

{zone-data:proposer-list}
[Pádraic Brady|mailto:padraic.brady@yahoo.com]
{zone-data}

{zone-data:revision} 
1.2 - 26 June 2007
{zone-data}

{zone-data:overview}
The purpose of the Zend_View Enhanced proposal is to propose the addition of Zend_View_Abstract methods, and Zend_View_Helper_* classes, which in combination provide for the ability to generate output in a flexible manner which adheres to the separation of Controller and View, advocates decoupling, and maintains backwards compatibility with the 1.0.0GA version of the Framework, and subsequent minor releases.

At present, Zend_View is a strict implementation of the Template View design pattern. It excels at templating, but has no native functionality for handling several key requirements of the View. This typically includes decorating templates with a common layout, supporting the rendering of templates in their own independent variable scope, allowing templates to transport additional presentation logic into other templates transparently, making calls into the Controller for additional embeddable output, and capturing common presentation logic as View Helpers. Suggested terms for these features:

   1. Layouts
   2. Partials
   3. Controllers
   4. Placeholders
   5. View Helpers (as now)

The common perception is that the Controller is required to facilitate many of these View features. Unfortunately, this is misleading. These approaches have no such dependency on the Controller unless such a dependency is implemented purposefully. All of the above are already standard for templating engines in several frameworks - even Smarty has native capabilities for many of these. The Controller is not a requirement for their implementation.

The argument this idea springs from is that Controller based solutions inevitably require far more code. This in turn requires more processing (and a possible performance hit), and the writing of a multitude of additional Controllers. Controller based approaches usually violate KISS (Keep It Simple Stupid) and are not a replacement for View based functions which are available as part and parcel of the template syntax.

The proposal, however, makes no assumptions about the Controller. The only such assumption is that a minor issue may be resolved (#ZF-1545). If no resolution is forthcoming, an alternate means of implementation may be used.

Wherever possible, View Helpers are preferred in place of adding code directly to Zend_View_Abstract. A number of these View Helpers have been proposed which capture the above four concepts, and add specialised variants to simplify template authoring. These expand the reach of View Helpers primarily to the <head> section of a HTML document where a lot of activity around Javascript, CSS, meta tags, etc. may be controlled outside a Layout within the actual sub-templates (a common requirement of any nested View design).

The proposed additions maintain Zend_View's decoupling from Zend_Controller. They should (as a requirement) have no conflict with Controller integrated strategies for similar features. There are therefore no conflicts with the addition of Controller based variants for Layouts such as the introduction of a Two-Step View implementation. It is noted that 

The additions are therefore quite straight forward, easy to implement, and pose no threat to backwards compatibility.
{zone-data}

{zone-data:references}
* [Sample implementation in Subversion (this source code is not a complete implementation as this proposal has yet to be reviewed)|http://svn.astrumfutura.org/zendframework/trunk/library/Proposed/Zend/View]
* [Relevant blog post discussing the concepts|http://blog.astrumfutura.com/archives/291-Complex-Views-with-the-Zend-Framework-Part-6-Setting-The-Terminology.html]
* [Relevant blog post discussing Zend_View Enhanced|http://blog.astrumfutura.com/archives/295-Complex-Views-with-the-Zend-Framework-Part-7-Zend_View-Enhanced.html]
* [Symfony Documentation for its View Layer|http://www.symfony-project.com/book/trunk/07-Inside-the-View-Layer]
* [The venerable Smarty library|http://smarty.php.net/manual/en/] (much of the above is already possible using plain old Smarty)
{zone-data}

{zone-data:requirements}
* *Must* implement the 4 view construction strategies (Layout, Partial, Controller, Placeholder)
* *Must* implement several specialised View Helpers for controlling Element additions to the <head>
* *Must* maintain backwards compatibility with Zend_View and Zend_Controller_Action_Helper_ViewRenderer
* *Must* (where feasible) be implemented as default View Helpers
* *Should not* prevent or restrict Controller derived strategies for output construction
* *Must* be accompanied by a full set of integration tests prior to acceptance in Core
* *May optionally require* adoption of the setters suggested in [#ZF-1545|http://framework.zend.com/issues/browse/ZF-1545]
{zone-data}

{zone-data:dependencies}
* Zend_View_Abstract
* Zend_View_Exception
* Zend_Controller_* (only for Controller strategy)
{zone-data}

{zone-data:operation}
Zend_View Enhanced advocates a template driven approach to output generation. As templates are rendered by Zend_View, the templates themselves may invoke Partials and Controllers, as well as set Placeholder content (template specific or default) which is centrally stored for higher level and subsequent templates (such as Layouts) to utilise. Layouts are applied at the end of any Zend_View instance's rendering process to take advantage of Placeholders, and their specialised variants.

Partials: Partials simply render a specified template within it's own separate variable scope. This is useful for reusable template fragments, avoids variable name clashes, and allows configuration of Partials to include from independent Modules (i.e. using that Module's helpers/filters/paths). At a higher level, Partials implement the Composite View design pattern allowing for the generation of a tree of View objects for even more flexibility.

Controllers: Dispatches a request to the Controller which returns output for embedding in a template. This must be compatible with ViewRenderer. May be used for querying the Model, but it's generally recommended to use a View Helper where possible. Most likely useful where authentication or authorisation must also be queried before Model access, or where existing Controllers can be reused as an alternative to implementing more View Helpers.

Layouts: Decorates the main output of a Zend_View instance with a Layout template composed of common page elements and Placeholders for context specific additions which are defined by templates prior to the Layout rendering. Layouts in Zend_View are implemented in a simple manner - they are the only feature requiring editing of Zend_View_Abstract.

Placeholders: Allows templates to set centrally registered content for inclusion in any subsequently rendered template or Layout. Placeholders are sufficiently decoupled from templates so that templates from different variable scopes can still communicate data to each other. Set Placeholders are only ever available to templates rendered after the Placeholder is set. Placeholders may be used for HTML elements which require a strict order of addition (e.g. Javascript <script> tags), or alternatively a specialised HTML generating Helper (e.g. Zend_View_Helper_HeadScript) can be used instead. See next.

HTML <head> View Helpers: Utilise Placeholders in a pre-defined namespace to dynamically control the construction of a Layout's <head> section. This eases the common use cases of using sub-templates to dynamically define additional Javascript, CSS, Metas, and other such elements for inclusion in a Layout.
{zone-data}

{zone-data:milestones}
* Milestone 1: Write unit tests capturing the agreed interface and behaviour
* Milestone 2: Write the code required to pass all unit tests
* Milestone 3: Write integration tests to cover various edge cases
* Milestone 4: Verify that code does not compromise backwards compatibility with ZF 1.0.0GA
* Milestone 5: Complete documentation
{zone-data}

{zone-data:class-list}
* Zend_View_Abstract
* Zend_View_Factory
* Zend_View_Helper_Placeholder
* Zend_View_Helper_Controller
* Zend_View_Helper_Partial
* Zend_View_Helper_HeadTitle
* Zend_View_Helper_HeadScript
* Zend_View_Helper_HeadLink
* Zend_View_Helper_HeadMeta
* Zend_View_Helper_HeadStyle
* Zend_View_Helper_Doctype
{zone-data}

{zone-data:use-cases}
||UC-01||

*Partial Use Case*

Partials render a template fragment at a specific location within another template. They are rendered in a separate variable scope with a Model supplied by the parent template. It is assumed Partials can therefore be easily rendered from different Modules.

Partials implement the Composite View Pattern defined in J2EE Design Patterns. Although template fragment rendering is likely the majority use case, partials are infinitely nestable and can thus compose a nested tree of Zend_View objects for above average complex Views.

*./src/default/views/scripts/blog/index.phtml*
{code:php}
<?php echo $this->render('stdHeader.phtml') ?>

    <div class="blog content">
        <?php foreach($this->entries as $entry): ?>
            <?php echo $this->partial('_entry.phtml', array('entry'=>$entry)) ?>
        <?php endforeach; ?>
    </div>

<?php echo $this->render('stdFooter.phtml') ?>
{code}

*./src/default/views/scripts/blog/_entry.phtml*
{code:php}
<div class="entry">
    <ul class="meta">
        <li><?php echo $this->entry->author; ?></li>
        <li><?php echo $this->entry->date; ?></li>
        <li><?php echo $this->entry->comments; ?></li>
    </ul>
    <div class="entry body">
        <?php echo $this->entry->text; ?>
    </div>
</div>
{code}

||UC-02||

*Controller Use Case*

The Controller View Helper enables templates to dispatch any given Controller and Action. The contents of the Response object resulting from this dispatch is then rendered in the calling template. Controller should never be used to alter the Model in this fashion - but are highly usable to enable the embedding of an existing Controller's output into an application.

*./src/default/views/scripts/blog/index.phtml*
{code:php}
<?php echo $this->render('stdHeader.phtml'); ?>

    <div id="content">
        Some content of main body in page...
    </div id="content">
    <div id="sidebar right">
        <?php echo $this->controller('list', 'comment', null, array('count'=>10)); ?>
    </div>

<?php echo $this->render('stdFooter.phtml'); ?>
{code}

||UC-03||

*Layout Use Case*

Layouts are templates which decorate the rendered output of a View. The decoration is handled internally by Zend_View_Abstract::render() by allowing Layouts to define an insertion point for the main output to be placed. Layouts are quite flexible, the primary insertion point for the main rendered output is just a typical Placeholder proxied by the getContentLayout() method.

*./src/bootstrap.php*
{code:php}
$view = new Zend_View;
$view->setBasePath(APPLICATION_PATH . DIRECTORY_SEPARATOR . 'default/views');
$view->setLayout('layout.phtml'); // manually handled, could be automated by ViewRenderer
$viewRenderer = new Zend_Controller_Action_Helper_ViewRenderer;
$viewRenderer->setView($view);
Zend_Controller_Action_HelperBroker::addHelper($viewRenderer);
{code}

*./src/default/view/scripts/layout.phtml*
{code:php}
<?php echo $this->doctype('XHTML 1.0 Strict') ?>
<html>
<head>
<title>My Application</title>
<link rel="stylesheet" type="text/css" href="styles/base.css" media="screen">
</head>
<body>
<div id="main">
    <?php echo $this->getContentLayout(); ?>
</div>
<div id="footer">
    <p><small>Copyright &copy; 2007 Pádraic Brady</small></p>
</div>
</body>
</html>
{code}


||UC-04||

*Placeholder Use Case*

Placeholders are centrally registered pieces of content which all subsequently rendered templates may access. Since Layouts are always rendered last - they may access all set Placeholders. Placeholders may be set with a specific order attached. This is beyond the scope of the the following Use Case which does not differentiate between <head> descendant elements.

*./src/bootstrap.php*
{code:php}
$view = new Zend_View;
$view->setBasePath(APPLICATION_PATH . DIRECTORY_SEPARATOR . 'default/views');
$view->setLayout('layout.phtml'); // manually handled, could be automated by ViewRenderer
$viewRenderer = new Zend_Controller_Action_Helper_ViewRenderer;
$viewRenderer->setView($view);
Zend_Controller_Action_HelperBroker::addHelper($viewRenderer);
{code}

*./src/default/view/scripts/layout.phtml*
{code:php}
<?php echo $this->doctype('XHTML 1.0 Strict') ?>
<html>
<head>
    <?php echo $this->headTitle() ?>
    <link rel="stylesheet" type="text/css" href="styles/base.css" media="screen">
    <?php echo $this->headLink() ?>
</head>
<body>
<div id="main">
    <?php echo $this->getLayoutContent(); ?>
</div>
<div id="footer">
    <p>
    <?php if($this->placeholder()->has('license')): ?>
        <?php echo $this->placeholder->get('LICENSE'); ?>
    <?php else: ?>
        Licensed under the <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation License</a>.
    <?php endif; ?>
    </p>
    <p><small>Copyright &copy; 2007 Pádraic Brady</small></p>
</div>
</body>
</html>
{code}

*./src/default/view/scripts/blog/index.phtml*
{code:php}
<?php $this->headLink(array('rel'=>'alternate', 'type'=>'application/rss+xml', 'title'=>'RSS', 'href'=>'http://www.planet-php.org/rss/')); ?>
<?php $this->placeholder->set('license', 'Licensed under a <a href="http://creativecommons.org/licenses/by/1.0/">Creative Commons License</a>.'); ?>

<div class="blog content">
    <?php foreach($this->entries as $entry): ?>
        <?php echo $this->partial('_entry.phtml', array('entry'=>$entry)) ?>
    <?php endforeach; ?>
</div>
{code}

{zone-data}

{zone-data:skeletons}
*Zend_View_Abstract: Extract showing additional public methods proposed*
{code:php}
/**
 * Abstract class for Zend_View to help enforce private constructs.
 *
 * @category   Zend
 * @package    Zend_View
 * @copyright  Copyright (c) 2005-2007 Zend Technologies USA Inc. (http://www.zend.com)
 * @license    http://framework.zend.com/license/new-bsd     New BSD License
 */
abstract class Zend_View_Abstract implements Zend_View_Interface
{

    /**
     * Stores a Factory instance for creating Zend_View objects
     *
     * @var Zend_View_Factory
     */
    private static $_factory = null;

    /**
     * The Layout template for this View if enabled
     *
     * @var string
     */
    protected $_layoutFile = null;

    /**
     * The main template being rendered by this View, ignoring other secondary
     * templates rendered by subsequent Zend_View::render() calls.
     *
     * @var string
     */
    protected $_fileToRender = null;

    /**
     * Constructor.
     *
     * @param array $config Configuration key-value pairs.
     */
    public function __construct($config = array())
    {}

    /**
     * Processes a view script and returns the output. If enabled it will also
     * decorate the output with a rendered Layout file.
     *
     * @see Zend_View_Abstract::contentForLayout()
     * @param string $name The script script name to process.
     * @return string The script output.
     */
    public function render($name)
    {}

    /**
     * Set the filename of a Layout template to be used. The existence of a
     * Layout filename will cause the final rendered View to be stored until
     * the rendered Layout includes it by calling Zend_View::content().
     *
     * @param $file string
     * @return void
     */
    public function setLayout($name)
    {}

    /**
     * Return the filename of the Layout.
     *
     * @return string
     */
    public function getLayout()
    {}

    /**
     * Returns true if a Layout has been set for this View.
     *
     * @return bool
     */
    public function hasLayout()
    {}

    /**
     * Simple accessor to return pre-rendered content of the main template
     *
     * @return string
     */
    public function getLayoutContent()
    {}

    /**
     * Set an instance of Zend_View_Factory as a singleton Factory instance
     *
     * @param Zend_View_Factory
     * @return void
     */
    public static function setFactory(Zend_View_Factory_Interface $factory)
    {}

    /**
     * Return the static singleton Factory instance
     *
     * @return Zend_View_Factory
     */
    public static function getFactory()
    {}

    /**
     * Use to include the view script in a scope that only allows public 
     * members.
     * 
     * @return mixed
     */
    abstract protected function _run();
}
{code}

*Zend_View_Helper_Partial*
{code:php}
/**
 * Helper for rendering a template fragment in its own variable scope.
 *
 * @package    Zend_View
 * @subpackage Helpers
 * @copyright  Copyright (c) 2007 Pádraic Brady (http://blog.astrumfutura.com)
 * @license    New BSD
 */
class Zend_View_Helper_Partial {

    /**
     * Instance of parent Zend_View object
     *
     * @var Zend_View_Abstract
     */
    public $view = null;

    /**
     * Renders a template fragment within a variable scope distinct from the
     * calling View object.
     *
     * @param string $name
     * @param string|array $module
     * @param array $model
     * @returns string $output
     */
    public function partial($name, $module = null, array $model = null)
    {}

    /**
     * Set view object
     *
     * @param  Zend_View_Interface $view
     * @return Zend_View_Helper_Partial
     */
    public function setView(Zend_View_Interface $view)
    {}

    /**
     * Clone the current View within resorting to a Factory call
     *
     * @param  Zend_View_Interface $view
     * @return Zend_View_Helper_Partial
     */
    protected function _cloneView(array $viewModel = null)
    {}

}
{code}

*Zend_View_Helper_Controller*
{code:php}
/**
 * Helper for embedding the response output of an existing Controller action.
 * 
 * @package    Zend_View
 * @subpackage Helpers
 * @copyright  Copyright (c) 2007 Pádraic Brady (http://blog.astrumfutura.com)
 * @license    http://framework.zend.com/license/new-bsd     New BSD License
 */
class Zend_View_Helper_Controller {

    /**
     * Dispatch a request via the Controller and fetch the resulting rendered
     * View to return
     *
     * @param string $action
     * @param string $controller
     * @param string $module
     * @param array $params
     * @returns string
     * @todo Breaks with the ViewRenderer enabled (ZF-1545)
     */
    public function controller($action, $controller = null, $module = null, array $params = null)
    {}

}
{code}

*Zend_View_Helper_Placeholder*

By allowing templates within the Composite View tree (i.e. nested render() calls, partials etc.) access a central object which all View objects may access as a central Registry, it becomes possible for nested templates, irrespective of nest depth, to influence their top-level decorating Layout, or subsequently rendered templates, by setting values these may later refer to.

All values are stored in arrays. This enables Placeholders to maintain an indexed set of values, where the order of inclusion at a rendering point is determined by this indexation, or a user defined ordering function. At present the ordering defaults to ksort() but can be expanded to allow user defined callback functions to manage such ordering in an easy to modify manner.

This strategy is built into a set of a pre-defined Placeholders for the <head> element of HTML documents in the proposed Zend_View_Helper_Head* helpers. More similar helpers may be proposed if their utility proves valuable. Their purpose is primarily to offer specialised usage of the basic Placeholder class using Proxies which are capable of outputting valid XHTML/HTML using the values set by the template authors, and optionally specific to a defined Doctype.

{code:php}
/**
 * Helper for passing data between otherwise segregated Views. It's called Placeholder to
 * make its typical usage obvious, but can be used just as easily for non-Placeholder
 * things. That said, the support for this is only guaranteed to effect subsequently rendered
 * templates, and of course Layouts.
 * This class is utilised by a number of specialised helpers such as Zend_View_Helper_HeadTitle
 *
 * @package    Zend_View
 * @subpackage Helpers
 * @copyright  Copyright (c) 2007 Pádraic Brady (http://blog.astrumfutura.com)
 * @license    New BSD
 */
class Zend_View_Helper_Placeholder {

    /**
     * Registry array to store Placeholder values for later queries from layouts or
     * templates.
     *
     * @var array
     */
    protected static $_registry = array();

    /**
     * Potential function for custom ordering of Placeholder key arrays prior to rendering
     *
     * @var mixed
     */
    protected $_callback = null;

    /**
     * Return the current object
     *
     * @return Zend_View_Helper_Placeholder
     */
    public function placeholder()
    {}

    /**
     * Check for the existence of the named Placeholder key
     *
     * @param string $key
     * @param mixed $index
     * @return bool
     */
    public function has($key, $index = null, $value = null)
    {}

    /**
     * Append a value string to an existing Placeholder key
     * without any overwriting or index value
     *
     * @param string $key
     * @param mixed $value
     * @return void
     */
    public function append($key, $value)
    {}

    /**
     * Sets the value for a Placeholder key, or sets the value for a specific index
     * on this key (e.g. to set a rendering order). If an index is not defined, it
     * is assumed a single value per key is to be set and any pre-existing array
     * will be replaced with this single value.
     *
     * If you want to set multiple values where ordering isn't necessary, use the
     * Zend_View_Helper_Placeholder::append() method instead. This will append
     * values using the default array indexation.
     *
     * @param string $key
     * @param mixed $value
     * @param mixed $index
     * @return void
     */
    public function set($key, $value, $index = null)
    {}

    /**
     * Return the value of a Placeholder key
     *
     * @param string $key
     * @param mixed $index
     * @return mixed
     */
    public function get($key, $index = null)
    {}

    /**
     * Unset the value of a Placeholder key
     *
     * @param string $key
     * @param mixed $index
     * @param string $value
     * @return void
     */
    public function remove($key, $index = null, $value = null)
    {}

    /**
     * Register a callback function which is passed the Placeholder array
     * for a given key, along with the key name. This callback function may
     * then proceed to order the array in such a way as to determine the
     * sorting order by which element values are rendered into the Placeholder
     * injection point in any calling template.
     *
     * @param string $function
     * @param object $object
     * @return void
     */
    public function registerCallback($function, $object = null)
    {}

    /**
     * Flatten the array of indexed values for output and return as
     * a string after the value array has been sorted.
     *
     * @param array $array
     * @return string
     */
    protected function _toString($array, $key = null)
    {}

}
{code}

*Zend_View_Factory*

Zend_View_Factory is a debatable implementation. How does one manage the instantiation and configuration of a View object without Controller access? The ViewRenderer object is very close to being a View Factory, so this class may simply act as a configurable Facade to that class. In either case it must allow for non-conventional directory layouts and thus should be configurable from an application's bootstrap to enable maximum flexibility in how a user may organise View paths.

{code:php}
class Zend_View_Factory
{
    /** 
     * Constructor; optionally set options.
     * 
     * @param array|Zend_Config $options 
     * @return void
     */
    public function __construct($options = null)
    {}

    /**
     * Create a Zend_View instance following the same conventions as ViewRenderer
     * which can be amended by declaring a set of options when creating the
     * Factory instance.
     *
     * @param string|array $module
     * @param array $model
     * @param Zend_View_Abstract
     * @return void
     */
    public function createInstance($module = null, array $model = null, Zend_View_Abstract $parentView = null)
    {}

    /**
     * Set view basePath specification
     *
     * Specification can contain one or more of the following:
     * - :moduleDir - parent directory of all modules
     * - :module - name of current module in the request
     * 
     * @param  string $path 
     * @return Zend_View_Factory
     */
    public function setViewBasePathSpec($path)
    {}

    /**
     * Retrieve the current view basePath specification string
     * 
     * @return string
     */
    public function getViewBasePathSpec()
    {}

}
{code}

*Zend_View_Helper_HeadTitle*

A small helper delegating to Zend_View_Helper_Placeholder which allows the user to utilise a default Placeholder for the express purpose of defining a page title for insertion into a Layout head element.

{code:php}
/**
 * Helper to insert or append <title> tags to the ZEND_HEAD Placeholder
 *
 * @category   Zend
 * @package    Zend_View
 * @subpackage Helper
 * @copyright  Copyright (c) 2007 Pádraic Brady
 * @license    http://framework.zend.com/license/new-bsd     New BSD License
 */
class Zend_View_Helper_HeadTitle
{

    /**
     * Instance of parent Zend_View object
     *
     * @var Zend_View_Abstract
     */
    public $view = null

    /**
     * The default Zend_View_Helper_Placeholder instance
     *
     * @var Zend_View_Helper_Placeholder
     */
    protected $_placeholder = null;

    /**
     * Constants
     */
    const HEADTITLE_NAMESPACE = 'ZEND_HEAD_TITLE';

    /**
     * Constructor; assigns a Zend_View_Helper_Placeholder object.
     */
    public function __construct()
    {}

    /**
     * Return self for further in-object calls
     *
     * @return Zend_View_Helper_HeadTitle
     */
    public function headTitle()
    {}

    /**
     * Set view object
     *
     * @param  Zend_View_Interface $view
     * @return Zend_View_Helper_HeadTitle
     */
    public function setView(Zend_View_Interface $view)
    {}

    /**
     * Check for the existence of the ZEND_TITLE Placeholder key
     *
     * @return bool
     */
    public function has()
    {}

    /**
     * Set the value for a Placeholder ZEND_TITLE key.
     * Overwrites existing value.
     *
     * @param mixed $value
     * @return void
     */
    public function set($value)
    {}

    /**
     * Return the value of a Placeholder ZEND_TITLE key
     *
     * @return mixed
     */
    public function get()
    {}

    /**
     * Unset the value of a Placeholder ZEND_TITLE key
     *
     * @param string $index
     * @return void
     */
    public function remove($index = null)
    {}

}
{code}

*Zend_View_Helper_HeadMeta*

A small helper delegating to Zend_View_Helper_Placeholder which allows the user to utilise a default Placeholder for the express purpose of defining page <meta> tags for insertion into a Layout head element.

{code:php}
/**
 * Helper to add a <meta> tag value to a head->meta Placeholder
 *
 * @category   Zend
 * @package    Zend_View
 * @subpackage Helper
 * @copyright  Copyright (c) 2007 Pádraic Brady
 * @license    http://framework.zend.com/license/new-bsd     New BSD License
 */
class Zend_View_Helper_HeadMeta
{

    /**
     * Instance of parent Zend_View object
     *
     * @var Zend_View_Abstract
     */
    public $view = null;

    /**
     * The default Zend_View_Helper_Placeholder instance
     *
     * @var Zend_View_Helper_Placeholder
     */
    protected $_placeholder = null;

    /**
     * Constants
     */
    const HEADMETA_NAMESPACE = 'ZEND_HEAD_META';

    /**
     * Append a Head <meta> value if a parameter and
     * return self for further in-object calls
     *
     * @return Zend_View_Helper_HeadMeta
     */
    public function headMeta($value = null)
    {}

    /**
     * Set view object
     *
     * @param  Zend_View_Interface $view
     * @return Zend_View_Helper_HeadTitle
     */
    public function setView(Zend_View_Interface $view)
    {}

    /**
     * Check for the existence of the self::HEADMETA_NAMESPACE Placeholder key
     *
     * @return bool
     */
    public function has($index = null, $value = null)
    {}

    /**
     * Append a value for a Placeholder self::HEADMETA_NAMESPACE key.
     *
     * @param mixed $value
     * @return void
     */
    public function append($value)
    {}

    /**
     * Return the value of a Placeholder self::HEADMETA_NAMESPACE key
     *
     * @return mixed
     */
    public function get($index = null)
    {}

    /**
     * Unset the value of a Placeholder self::HEADMETA_NAMESPACE key
     *
     * @param string $index
     * @return void
     */
    public function remove($index = null, $value = null)
    {}

    /**
     * toString function for this class
     *
     * @return string
     */
    public function __toString() {
        return $this->get();
    }

}
{code}

*Zend_View_Helper_HeadStyle*

A small helper delegating to Zend_View_Helper_Placeholder which allows the user to utilise a default Placeholder for the express purpose of defining page <style> tags for insertion into a Layout head element.

{code:php}
/**
 * Helper to add a <style> tag value to a head->style Placeholder
 *
 * @category   Zend
 * @package    Zend_View
 * @subpackage Helper
 * @copyright  Copyright (c) 2007 Pádraic Brady
 * @license    http://framework.zend.com/license/new-bsd     New BSD License
 */
class Zend_View_Helper_HeadStyle
{

    /**
     * Instance of parent Zend_View object
     *
     * @var Zend_View_Abstract
     */
    public $view = null;

    /**
     * The default Zend_View_Helper_Placeholder instance
     *
     * @var Zend_View_Helper_Placeholder
     */
    protected $_placeholder = null;

    /**
     * Constants
     */
    const HEADSTYLE_NAMESPACE = 'ZEND_HEAD_STYLE';

    /**
     * Append a Head <meta> value if a parameter and
     * return self for further in-object calls
     *
     * @return Zend_View_Helper_HeadStyle
     */
    public function headStyle($value = null)
    {}

    /**
     * Set view object
     *
     * @param  Zend_View_Interface $view
     * @return Zend_View_Helper_HeadStyle
     */
    public function setView(Zend_View_Interface $view)
    {}

    /**
     * Check for the existence of the self::HEADSTYLE_NAMESPACE Placeholder key
     *
     * @return bool
     */
    public function has($index = null, $value = null)
    {}

    /**
     * Append a value for a Placeholder self::HEADSTYLE_NAMESPACE key.
     *
     * @param mixed $value
     * @return void
     */
    public function append($value)
    {}

    /**
     * Return the value of a Placeholder self::HEADSTYLE_NAMESPACE key
     *
     * @return mixed
     */
    public function get($index = null)
    {}

    /**
     * Unset the value of a Placeholder self::HEADSTYLE_NAMESPACE key
     *
     * @param string $index
     * @return void
     */
    public function remove($index = null, $value = null)
    {}

    /**
     * toString function for this class
     *
     * @return string
     */
    public function __toString() {
        return $this->get();
    }

}
{code}

*Zend_View_Helper_HeadScript*

Include a Script file, or code block with a <head> element. Can avail of indexation to ensure Scripts are included in a preferred order.

{code:php}
/**
 * Helper to insert or append <script> tags to the head->script Placeholder
 *
 * @category   Zend
 * @package    Zend_View
 * @subpackage Helper
 * @copyright  Copyright (c) 2007 Pádraic Brady
 * @license    http://framework.zend.com/license/new-bsd     New BSD License
 */
class Zend_View_Helper_HeadScript
{

    /**
     * Instance of parent Zend_View object
     *
     * @var Zend_View_Abstract
     */
    public $view = null;

    /**
     * The default Zend_View_Helper_Placeholder instance
     *
     * @var Zend_View_Helper_Placeholder
     */
    protected $_placeholder = null;

    /**
     * Constants
     */
    const HEADSCRIPT_NAMESPACE = 'ZEND_HEAD_SCRIPT';

    /**
     * Return self for further in-object calls
     *
     * @return Zend_View_Helper_HeadScript
     */
    public function headScript($file = null, $type = null, $index = null)
    {}

    /**
     * Check for the existence of the self::HEADSCRIPT_NAMESPACE Placeholder key
     *
     * @return bool
     */
    public function has($index = null, $file = null, $type = 'javascript')
    {}

    /**
     * Append a value for a Placeholder self::HEADSCRIPT_NAMESPACE key.
     *
     * @param mixed $value
     * @return void
     */
    public function append($file, $type = null, $index = null)
    {}

    /**
     * Append a script-block value for a Placeholder self::HEADSCRIPT_NAMESPACE key.
     *
     * @param mixed $value
     * @return void
     */
    public function appendScript($code, $type = null, $index = null)
    {}

    /**
     * Return the value of a Placeholder self::HEADSCRIPT_NAMESPACE key
     *
     * @return mixed
     */
    public function get($index = null)
    {}

    /**
     * Unset the value of a Placeholder self::HEADSCRIPT_NAMESPACE key
     *
     * @param string $index
     * @return void
     */
    public function remove($index = null, $file = null, $type = 'javascript')
    {}

    /**
     * Alias to toString for public API
     * 
     * @return string
     */
    public function toString($index = null)
    {}

    /**
     * toString function for this class
     *
     * @return string
     */
    public function __toString($index = null)
    {
    }

    /**
     * Set view object
     *
     * @param  Zend_View_Interface $view
     * @return Zend_View_Helper_HeadScript
     */
    public function setView(Zend_View_Interface $view)
    {}

    /**
     * Return a type attribute value for the <script> element
     *
     * @param string $type
     * @return string
     */
    protected function _getType($type)
    {}

}
{code}

*Zend_View_Helper_Link*

Add a Link element based on an array of attributes to be added to the <head> section of a template or layout. Although this can also handle style sheets, it may prove more useful to use the HeadStyle View Helper to segregate styles from other types of relationship links.

{code:php}
/**
 * Helper to add a <link> tag value to a head->link Placeholder
 *
 * @category   Zend
 * @package    Zend_View
 * @subpackage Helper
 * @copyright  Copyright (c) 2007 Pádraic Brady
 * @license    http://framework.zend.com/license/new-bsd     New BSD License
 */
class Zend_View_Helper_HeadLink
{

    /**
     * Instance of parent Zend_View object
     *
     * @var Zend_View_Abstract
     */
    public $view = null;

    /**
     * The default Zend_View_Helper_Placeholder instance
     *
     * @var Zend_View_Helper_Placeholder
     */
    protected $_placeholder = null;

    /**
     * Attributes common to <link> elements
     *
     * @var string
     */
    protected $_attributes = array('href', 'charset', 'hreflang', 'media', 'rel', 'rev', 'target', 'type', 'id', 'class', 'title', 'style', 'dir', 'lang', 'xml:lang');

    /**
     * Constants
     */
    const HEADLINK_NAMESPACE = 'ZEND_HEAD_LINK';

    /**
     * Set the Head <link> value if a parameter and
     * return self for further in-object call
     *
     * @param array $attributes
     * @return Zend_View_Helper_HeadLink
     */
    public function headLink(array $attributes = null)
    {}

    /**
     * Set view object
     *
     * @param  Zend_View_Interface $view
     * @return Zend_View_Helper_HeadLink
     */
    public function setView(Zend_View_Interface $view)
    {}

    /**
     * Check for the existence of the self::HEADLINK_NAMESPACE Placeholder key
     *
     * @return bool
     */
    public function has($index = null, array $attributes = null)
    {}

    /**
     * Set the value for a Placeholder self::HEADLINK_NAMESPACE key.
     * Overwrites existing value.
     *
     * @param array $attributes
     * @param int $index
     * @return Zend_View_Helper_HeadLink
     */
    public function append(array $attributes, $index = null)
    {}

    /**
     * Return the value of a Placeholder self::HEADLINK_NAMESPACE key
     *
     * @return mixed
     */
    public function get($index = null)
    {}

    /**
     * Unset the value of a Placeholder self::HEADLINK_NAMESPACE key
     *
     * @param int $index
     * @return Zend_View_Helper_HeadLink
     */
    public function remove($index, array $attributes = null)
    {}

    /**
     * Alias to toString for public API
     * 
     * @param int $index
     * @return string
     */
    public function toString($index = null)
    {}

    /**
     * __toString function for this class
     *
     * @param int $index
     * @return string
     */
    public function __toString($index = null)
    {}

    /**
     * Merges key=>value pairs into a form suitable for insertion into
     * a <link> string.
     *
     * @param array $attributes
     * @return string
     */
    protected function _merge(array $attributes)
    {}

}

{code}

*Zend_View_Helper_Doctype*

Obtain the Doctype string based on the Standard name for HTML, XHTML, MathML and SVG.

{code:php}
/**
 * Helper to obtain a doctype declaration based on the $standard parameter
 * which reflects the full name of the standard including version and context
 *
 * @category   Zend
 * @package    Zend_View
 * @subpackage Helper
 * @copyright  Copyright (c) 2007 Pádraic Brady
 * @license    http://framework.zend.com/license/new-bsd     New BSD License
 */
class Zend_View_Helper_Doctype
{

    public function doctype($standard = 'XHTML 1.0 Transitional')
    {}

    protected function _doctypeXhtml($standard) 
    {}

    protected function _doctypeHtml($standard)
    {}

    protected function _doctypeMath($standard)
    {}

    protected function _doctypeSvg($standard)
    {}

}
{code}
{zone-data}

{zone-template-instance}